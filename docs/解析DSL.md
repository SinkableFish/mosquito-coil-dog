根据我们的设计，MCDog需要解析基于json的DSL。

当使用者（接口规则定制者）将动态定义的服务提交给MCDog后，MCDog会进行最终的有效性校验，方式为解析用户提交的服务DSL片段。

原计划在校验和解析dsl采用AST方案，不过，考虑到这个方案的复杂性和收益，最终放弃了。举个例子，例如自定义函数类型的任务校验规则中，原本考虑增加对`done()`的调用监督，以确保用户自定义的函数一定会调用该回调函数。但实际情况是，很难简单的断定该回调在函数体的任何分支中最终都会被调用。即便我们拿到语法树，也很难做出期望的判断。相反，在生成代码时我们只需要将函数包装在promis中并提供默认的超时时间即可更好的完成目标。

![](https://github.com/kazaff/mosquito-coil-dog/blob/master/docs/state_machine.png)

将DSL定义最终生成可执行的代码片段，其它语言中类似的场景会采用生成代码片段并动态编译加载，该方案依然适配nodejs。

其实，我们可以在开发环境下搭建MCDog，并将需要的工作流都创建好并设置为上线状态，然后在生产环境跑一套没有管理后台的MCDog，完全不需要在生产环境中搭建Redis（默认的工作流元数据持久化介质）。这是因为，MCDog将上线的工作流解析并生成对应的执行逻辑js文件（放在MCDog目录下的`compiled_services`文件夹中），每次启动MCDog时都会扫描这些文件并直接加载并绑定它们供第三方调用。
